#include <locale>
#include <fstream>
#include <string>
#include <iostream>
#include <vector>
#include "math.h"

using namespace std;

struct Unbond
{
	int left, right;
};
struct Distance
{
	float x, y, z, R;
};
struct Bond
{
	int left, right;
};
struct Angle :Bond
{
	int center;
};
struct Atom
{
	int n_atom;
	double x, y, z;
};
const float pi = 3.141592653589793238462643, T = 298.15, Kb = 1.38065812 * pow(10, -23), eps_0 = 8.85418785 * pow(10, -12), q = 1.6021773349 * pow(10, -19);
class Brownian_Dynamics
{
private:
	vector<Atom> data_atom
	vector<Bond> data_bond
	vector<Angle> data_angle
	vector<Distance> data_Dist_bonds;
	vector<double> Fbond_conn;
	vector<double> Fx0conn, Fy0conn, Fz0conn;
	vector<double> Funbond_disconn;
	vector<double> Fx0disconn, Fy0disconn, Fz0disconn;
	vector<double> Fx, Fy, Fz;
	vector<double> Fangle, Fangle_X, Fangle_Y, Fangle_Z;
	vector<double> Fsurf;
	vector<int> vetki;
	//for SCF
	vector<double> phi, phi_0, phi_asterisk, phi_Na, phi_Cl;
	vector<double> total_q;
	vector<double> psi, psi_0;
	vector<double> n_balls;
	vector<double> phi_solvent, phi_solvent_average;
	vector<double> V, V0;
	vector<double> Uself, Umf, Uint, Uel;
	vector<double> Fmf;
	string BONDS, ANGL, COORD, OutCoord, OutPdb, mode, check = "new";
	bool type_init;
	double dt, KbT, Lb, Kbond, diA, eps, rcut, solvent, viscFric, flow_velocity, theta_0, k_theta, mol_den;
	double regulsation, lambda_fh, chi, alpha, phibulk_salt;
	double lattice_size, epsilon_medium, f;
	int n_atoms, n_bonds, n_unbonds, print_to_pdb, nstepBD, nstepSCF, num_layer_y, size_area, m_mol, surf_area, num_angles;
	void SetResize_vectors()
	{
		data_Dist_bonds.resize(n_bonds);
		Fbond_conn.resize(n_bonds);
		Fx0conn.resize(n_atoms);
		Fy0conn.resize(n_atoms);
		Fz0conn.resize(n_atoms);
		Fx.resize(n_atoms);
		Fy.resize(n_atoms);
		Fz.resize(n_atoms);
		Fangle.resize(num_angles);
		Fangle_X.resize(n_atoms);
		Fangle_Y.resize(n_atoms);
		Fangle_Z.resize(n_atoms);
		Fsurf.resize(n_atoms);
		//for SCF
		phi.resize(num_layer_y + 2);
		n_balls.resize(num_layer_y + 2);
		phi_Na.resize(num_layer_y + 2);
		phi_Cl.resize(num_layer_y + 2);
		phi_asterisk.resize(num_layer_y + 2);
		psi.resize(num_layer_y + 2);
		psi_0.resize(num_layer_y + 2);
		phi_solvent.resize(num_layer_y + 2);
		phi_solvent_average.resize(num_layer_y + 2);
		V.resize(num_layer_y + 2);
		V0.resize(num_layer_y + 2);
		Uself.resize(num_layer_y + 2);
		Umf.resize(num_layer_y + 2);
		Uint.resize(num_layer_y + 2);
		Uel.resize(num_layer_y + 2);
		Fmf.resize(num_layer_y + 2);
		total_q.resize(num_layer_y + 2);

	}
	double RandomFloat()
	{
		return (double)rand() / RAND_MAX;
	}
	double normalRand()
	{
		static bool bgen = true;
		static double z0, z1;

		if (bgen)
		{
			double z, f;
			do
			{
				z = RandomFloat();
			} while (z < 1e-8);
			f = RandomFloat();
			z0 = cos(2 * pi * f) * sqrt(-2 * log(z));
			z1 = sin(2 * pi * f) * sqrt(-2 * log(z));
			bgen = false;
			return z0;
		}
		else
		{
			bgen = true;
			return z1;
		}
	}
public:
	void SetPrint_file(int t)
	{
		char Name[4] = "N  ";
		char Compound[5] = "unk ";
		FILE* hfile;
		if (t == 0)
		{
			hfile = fopen("out.pdb", "w");
		}
		else
		{
			hfile = fopen("out.pdb", "a");
		}
		fprintf(hfile, "COMPND    UNNAMED\n");
		fprintf(hfile, "AUTHOR    GENERATED BY TvGU\n");
		fprintf(hfile, "MODEL        %d\n", t);
		for (int k = 0; k < n_atoms; k++)
		{
			fprintf(hfile, "ATOM%7d  %3s%4s A%4d    %8.3f%8.3f%8.3f%6.2f%6.2f         %3s\n",
				k + 1, Name, Compound, 1, data_atoms[k].x, data_atoms[k].y, data_atoms[k].z, 1.00, 0.00, Name);
		}
		for (int k = 0; k < n_bonds; k++)
		{
			fprintf(hfile, "CONECT%5d%5d\n", data_bonds[k].left, data_bonds[k].right);
		}
		fprintf(hfile, "TER\n");
		fprintf(hfile, "ENDMDL\n");
		fclose(hfile);
	}
	void SetMove_corpuscle(int j, int k)
	{
		double lyambda = sqrt(2.0 * KbT * dt / viscFric);
		int counter = 0;
		for (int i = 0; i < n_atoms; ++i)
		{
			if ((i == vetki[counter]) || !i)
			{
				if (i && (counter + 1 != vetki.size())) counter++;
			}
			else
			{
				data_atoms[i].x = data_atoms[i].x + dt / viscFric * (Fx0conn[i] + Fangle_X[i]) + V[data_atoms[i].y] * dt + lyambda * normalRand();
				data_atoms[i].y = data_atoms[i].y + dt / viscFric * (Fy0conn[i] + Fangle_Y[i] + Fmf[data_atoms[i].y] + Fsurf[i]) + lyambda * normalRand();
				data_atoms[i].z = data_atoms[i].z + dt / viscFric * (Fz0conn[i] + Fangle_Z[i]) + lyambda * normalRand();
			}
		}
	}
	void SetSumm_F()
	{
		for (int i = 0; i < n_atoms; ++i)
		{
			Fx[i] = Fx0conn[i] + Fx0disconn[i];
			Fy[i] = Fy0conn[i] + Fy0disconn[i];
			Fz[i] = Fz0conn[i] + Fz0disconn[i];
		}
	}
	void SetFsurface()
	{
		for (int i = 0; i < n_atoms; ++i)
		{
			if (data_atoms[i].y < 1 && data_atoms[i].y >= 0) Fsurf[i] = -4 * (-12 * pow(1.0 / data_atoms[i].y, 13) + 6 * pow(1.0 / data_atoms[i].y, 7));
			else if (data_atoms[i].y >= 1) Fsurf[i] = 0;
		}
	}
	void SetAngleStrength()
	{
		for (int i = 0; i < num_angles; ++i)
		{
			double dxik = data_atoms[data_angles[i].left - 1].x - data_atoms[data_angles[i].right - 1].x;
			double dxij = data_atoms[data_angles[i].left - 1].x - data_atoms[data_angles[i].center - 1].x;
			double dxjk = data_atoms[data_angles[i].right - 1].x - data_atoms[data_angles[i].center - 1].x;
			double dyik = data_atoms[data_angles[i].left - 1].y - data_atoms[data_angles[i].right - 1].y;
			double dyij = data_atoms[data_angles[i].left - 1].y - data_atoms[data_angles[i].center - 1].y;
			double dyjk = data_atoms[data_angles[i].right - 1].y - data_atoms[data_angles[i].center - 1].y;
			double dzik = data_atoms[data_angles[i].left - 1].z - data_atoms[data_angles[i].right - 1].z;
			double dzij = data_atoms[data_angles[i].left - 1].z - data_atoms[data_angles[i].center - 1].z;
			double dzjk = data_atoms[data_angles[i].right - 1].z - data_atoms[data_angles[i].center - 1].z;
			double znamenatel = sqrt(pow(dxij, 2) + pow(dyij, 2) + pow(dzij, 2)) * sqrt(pow(dxjk, 2) + pow(dyjk, 2) + pow(dzjk, 2));
			double chislitel = dxij * dxjk + dyij * dyjk + dzij * dzjk;
			double thetaijk = (180.0 / pi) * acos(chislitel / znamenatel);
			double rik = sqrt(pow(dxik, 2) + pow(dyik, 2) + pow(dzik, 2));
			Fangle[i] = k_theta * (thetaijk - theta_0);
			Fangle[i] /= rik;
			for (int i = 0; i < n_atoms; ++i)
			{
				Fangle_X[i] = Fangle_Y[i] = Fangle_Z[i] = 0;
			}
			Fangle_X[data_angles[i].left - 1] += -Fangle[i] * dxik;
			Fangle_X[data_angles[i].right - 1] += Fangle[i] * dxik;
			Fangle_Y[data_angles[i].left - 1] += -Fangle[i] * dyik;
			Fangle_Y[data_angles[i].right - 1] += Fangle[i] * dyik;
			Fangle_Z[data_angles[i].left - 1] += -Fangle[i] * dzik;
			Fangle_Z[data_angles[i].right - 1] += Fangle[i] * dzik;
		}
	}
	void SetFbond()
	{
		for (int i = 0; i < n_atoms; ++i)
		{
			Fx0conn[i] = Fy0conn[i] = Fz0conn[i] = 0;
		}
		for (int i = 0; i < n_bonds; ++i)
		{
			Fbond_conn[i] = Kbond * (data_Dist_bonds[i].R - Lb);
			Fbond_conn[i] = Fbond_conn[i] / data_Dist_bonds[i].R; //àíàëîãè÷íî ñ Funbond
			Fx0conn[data_bonds[i].left - 1] = Fx0conn[data_bonds[i].left - 1] - Fbond_conn[i] * data_Dist_bonds[i].x;
			Fx0conn[data_bonds[i].right - 1] = Fx0conn[data_bonds[i].right - 1] + Fbond_conn[i] * data_Dist_bonds[i].x;
			Fy0conn[data_bonds[i].left - 1] = Fy0conn[data_bonds[i].left - 1] - Fbond_conn[i] * data_Dist_bonds[i].y;
			Fy0conn[data_bonds[i].right - 1] = Fy0conn[data_bonds[i].right - 1] + Fbond_conn[i] * data_Dist_bonds[i].y;
			Fz0conn[data_bonds[i].left - 1] = Fz0conn[data_bonds[i].left - 1] - Fbond_conn[i] * data_Dist_bonds[i].z;
			Fz0conn[data_bonds[i].right - 1] = Fz0conn[data_bonds[i].right - 1] + Fbond_conn[i] * data_Dist_bonds[i].z;
		}
	}
	void SetDistance_ij()
	{ 
		for (int i = 0; i < n_bonds; ++i)
		{
			data_Dist_bonds[i].x = data_atoms[data_bonds[i].left - 1].x - data_atoms[data_bonds[i].right - 1].x;
			data_Dist_bonds[i].y = data_atoms[data_bonds[i].left - 1].y - data_atoms[data_bonds[i].right - 1].y;
			data_Dist_bonds[i].z = data_atoms[data_bonds[i].left - 1].z - data_atoms[data_bonds[i].right - 1].z;
			data_Dist_bonds[i].R = sqrt(pow(data_Dist_bonds[i].x, 2) + pow(data_Dist_bonds[i].y, 2) + pow(data_Dist_bonds[i].z, 2));
		}
	}
	void SetPar_for_brown()
	{
		string source = "input.txt";
		ifstream ifs(source, ifstream::in);
		string word;
		string fileCoord_Out, fileOut_pdb;
		while (ifs.good())
		{
			ifs >> word;
			if (word.find("input_bonds") != string::npos) ifs >> BONDS;
			if (word.find("input_angles") != string::npos) ifs >> ANGL;
			if (word.find("input_coord") != string::npos) ifs >> COORD;
			if (word.find("output_coord") != string::npos) ifs >> fileCoord_Out;
			if (word.find("output_pdb") != string::npos) ifs >> fileOut_pdb;
			if (word.find("period_pdb") != string::npos) ifs >> print_to_pdb;
			if (word.find("type_init") != string::npos)
			{
				ifs >> mode;
				if (mode == check) type_init = true;
				else type_init = false;
			}
			if (word.find("nstep_bd") != string::npos) ifs >> nstepBD;
			if (word.find("nsted_scf") != string::npos) ifs >> nstepSCF;
			if (word.find("dt") != string::npos) ifs >> dt;
			if (word.find("kBT") != string::npos) ifs >> KbT;
			if (word.find("viscosity") != string::npos) ifs >> viscFric;
			if (word.find("flow_velocity") != string::npos) ifs >> flow_velocity;
			if (word.find("l_bond") != string::npos) ifs >> Lb;
			if (word.find("k_bond") != string::npos) ifs >> Kbond;
			if (word.find("di_A") != string::npos) ifs >> diA;
			if (word.find("non_val_int_e") != string::npos) ifs >> eps;
			if (word.find("r_cut") != string::npos) ifs >> rcut;
			if (word.find("chi") != string::npos) ifs >> solvent;
			if (word.find("non_val_int_e") != string::npos) ifs >> eps;
			if (word.find("size_area") != string::npos) ifs >> size_area;
			if (word.find("m_mol") != string::npos) ifs >> m_mol;
			if (word.find("regulsation") != string::npos) ifs >> regulsation;
			if (word.find("lambda_fh") != string::npos) ifs >> lambda_fh;
			if (word.find("alpha") != string::npos) ifs >> alpha;
			if (word.find("lattice_size") != string::npos) ifs >> lattice_size;
			if (word.find("epsilon_medium") != string::npos) ifs >> epsilon_medium;
			if (word.find("phibulk_salt") != string::npos) ifs >> phibulk_salt;
			if (word.find("num_layer_y") != string::npos) ifs >> num_layer_y;
			if (word.find("k_theta") != string::npos) ifs >> k_theta;
			if (word.find("theta_0") != string::npos) ifs >> theta_0;
		}
		mol_den = 1.0 / size_area;
		surf_area = size_area * size_area * m_mol;
		f = (q * q) / (epsilon_medium * eps_0 * lattice_size * Kb * T);
	}
	void SetMaindata()
	{
		if (!type_init)
		{
			int left, right;
			string name_bond, name_atom;
			ifstream infile_bonds(BONDS, ifstream::in);
			infile_bonds >> name_bond >> n_bonds >> name_atom >> n_atoms;
			data_atoms.resize(n_atoms);
			data_bonds.resize(n_bonds);
			for (int i = 0; ; ++i)
			{
				infile_bonds >> left >> right;
				if (i)
				{
					if ((left == data_bonds[i - 1].left && right == data_bonds[i - 1].right)) break;
				}
				data_bonds[i].left = left;
				data_bonds[i].right = right;
			}
			infile_bonds.close();
			ifstream infile_coord(COORD, ifstream::in);
			for (int i = 0; i < n_atoms; ++i)
			{
				data_atoms[i].n_atom = i + 1;
				infile_coord >> data_atoms[i].x >> data_atoms[i].y >> data_atoms[i].z;
			}
			infile_coord.close();
		}
		else
		{
			int left, right;
			string name_bond, name_atom;
			ifstream infile_bonds(BONDS, ifstream::in);
			infile_bonds >> name_bond >> n_bonds >> name_atom >> n_atoms;
			int tempn_bonds = n_bonds;
			int tempn_atoms = n_atoms;
			int multi = tempn_atoms;
			n_atoms = m_mol * tempn_atoms;
			n_bonds = m_mol * tempn_bonds;
			data_atoms.resize(n_atoms);
			data_bonds.resize(n_bonds);
			for (int i = 0; ; ++i)
			{
				infile_bonds >> left >> right;
				if (i)
				{
					if ((left == data_bonds[i - 1].left && right == data_bonds[i - 1].right)) break;
				}
				data_bonds[i].left = left;
				data_bonds[i].right = right;

			}
			infile_bonds.close();
			int counter = 0;
			vetki.push_back(tempn_bonds + 1);
			int j = 0;
			for (int i = tempn_bonds; i < n_bonds; ++i)
			{
				if (j == tempn_bonds)
				{
					j = 0;
					multi += tempn_atoms;
					vetki.push_back(multi);
				}
				if (j < tempn_bonds)
				{
					data_bonds[i].left = data_bonds[j].left + multi;
					data_bonds[i].right = data_bonds[j].right + multi;
					j++;

				}
			}
			for (int i = 0; i < n_atoms; ++i)
			{
				data_atoms[i].n_atom = i + 1;
				if (!i || i == vetki[counter])
				{
					if (counter + 1 != vetki.size() && i) ++counter;
					else if (counter + 1 == vetki.size())
					{
						++counter;
						vetki.resize(counter + 1);
					}
					int j = counter % int(sqrt(m_mol));
					int k = counter / int(sqrt(m_mol));
					data_atoms[i].x = sqrt(size_area) / 2.0 + j * sqrt(size_area);
					data_atoms[i].y = diA / 2;
					data_atoms[i].z = sqrt(size_area) / 2.0 + k * sqrt(size_area);
				}
				else
				{
					double x = normalRand();
					data_atoms[i].x = x;
					double y = normalRand();
					if (y < (diA / 2))
					{
						while (y < (diA / 2))
						{
							y = normalRand();
							data_atoms[i].y = y;
						}
					}
					else data_atoms[i].y = y;
					double z = normalRand();
					data_atoms[i].z = z;
					double r = sqrt(pow(x, 2) + pow(y, 2) + pow(z, 2));
					data_atoms[i].x = data_atoms[i - 1].x + (Lb * x) / r;
					data_atoms[i].y = data_atoms[i - 1].y + (Lb * y) / r;
					data_atoms[i].z = data_atoms[i - 1].z + (Lb * z) / r;

				}
			}
			vetki.resize(counter);
			int center;
			ifstream infile_angle(ANGL, ifstream::in);
			string name;
			center = 0, left = 0, right = 0;
			infile_angle >> name >> num_angles;
			int tempnum_angles = num_angles;
			num_angles = m_mol * tempnum_angles;
			data_angles.resize(num_angles);
			for (int i = 0; ; ++i)
			{
				infile_angle >> left >> center >> right;
				if (i)
				{
					if ((left == data_angles[i - 1].left && right == data_angles[i - 1].right && center == data_angles[i - 1].center)) break;
				}
				data_angles[i].left = left;
				data_angles[i].center = center;
				data_angles[i].right = right;
			}
			infile_angle.close();
			j = 0;
			multi = tempn_atoms;
			for (int i = tempnum_angles; i < num_angles; ++i)
			{
				if (j == tempnum_angles)
				{
					j = 0;
					multi += tempn_atoms;
				}
				if (j < tempnum_angles)
				{
					data_angles[i].left = data_angles[j].left + multi;
					data_angles[i].right = data_angles[j].right + multi;
					data_angles[i].center = data_angles[j].center + multi;
					j++;

				}
			}
		}
	}
	void SetPhi_asterisk_Psi()
	{
		for (int r = 1; r <= num_layer_y; ++r)
		{
			phi_asterisk[r] = phi[r];
		}
		for (int i = 0; i < num_layer_y + 2; ++i)
		{
			psi[i] = 0;
		}
	}
	void SetPhi()
	{
		for (int i = 0; i < n_atoms; ++i)
		{
			for (int r = 1; r <= num_layer_y; ++r)
			{
				if (data_atoms[i].y >= r - 1 && data_atoms[i].y < r)
				{
					n_balls[r] += 1;
					break;
				}
			}
		}
		for (int r = 1; r <= num_layer_y; ++r)
		{
			phi[r] = n_balls[r] / surf_area;
		}
	}
	void output_data()
	{
		FILE* out1 = fopen("output_phi.txt", "w");
		fprintf(out1, "\tphi\t\tphi_solvent\t     phi_Na\t     phi_Cl\n");
		for (int i = 1; i < phi.size() - 1; ++i)
		{
			fprintf(out1, "%d\t%f\t%f\t%f\t%f\t\n", i,
				phi[i],
				phi_solvent[i],
				phi_Na[i],
				phi_Cl[i]);
		}
		fclose(out1);
		FILE* out2 = fopen("output_self.txt", "w");
		fprintf(out2, "\tUmf\t\tq\t\tPsi\t\tV\n");
		for (int i = 1; i < phi.size() - 1; ++i)
		{
			fprintf(out2, "%d\t%f\t%f\t%f\t%f\t\n", i,
				Umf[i],
				total_q[i],
				psi[i],
				V[i]);
		}
		fclose(out2);
		FILE* out3 = fopen("output.txt", "w");
		fprintf(out3, "ATOM\tx\t\ty\t\tz\n");
		for (int i = 0; i < n_atoms; ++i)
		{
			fprintf(out3, "%d\t%f\t%f\t%f\n", i + 1, data_atoms[i].x, data_atoms[i].y, data_atoms[i].z);
		}
		fclose(out3);
	}
	void SetFinalDensity()
	{
		for (int i = 0; i <= num_layer_y; ++i)
		{
			phi_asterisk[i] = phi_asterisk[i] + n_balls[i] / surf_area;
			phi_asterisk[i] = phi_asterisk[i] / nstepBD;
			phi[i] = eps_0 * phi_asterisk[i] + (1 - eps_0) * phi[i];
		}
	}
	void SetMol_Strength()
	{
		double deltaY = 1;
		for (int i = 1; i <= num_layer_y; ++i)
		{
			Fmf[i] = (Umf[i + deltaY] - Umf[i]) / deltaY;
		}
	}
	void SetSelfCons_and_Mol_fields()
	{
		for (int i = 1; i <= num_layer_y; ++i)
		{
			Uself[i] = -log(1 - phi[i]);
			Uint[i] = chi * (phi_solvent_average[i] - phibulk_salt);
			Uel[i] = alpha * psi[i];
			Umf[i] = Uself[i] + Uint[i] + Uel[i];
		}
	}
	void SetAverage_V()
	{
		V0[0] = 0;
		for (int i = 1; i <= num_layer_y - 1; ++i)
		{
			V[i] = (V0[i - 1] - 3 * pi * phi[i] * V0[i] + V0[i + 1]) / 2;
			if (phi[i] > 0) V0[i] = V[i];
			else if (phi[i] <= 0) V0[i] = flow_velocity;
			else V0[i] = 0;
		}

	}
	void SetSolvent_Distrib()
	{
		for (int i = 1; i <= num_layer_y; ++i)
		{
			phi_solvent[i] = 1 - phi[i] - phi_Na[i] - phi_Cl[i];
			phi_solvent_average[i] = lambda_fh * phi_solvent[i - 1] + (1 - 2 * lambda_fh) * phi_solvent[i] + lambda_fh * phi_solvent[i + 1];
		}
	}
	void SetBoltzman_ElectroPoten()
	{
		for (int i = 1; i <= num_layer_y; ++i)
		{
			psi[i] = (psi_0[i - 1] + f * total_q[i] + psi_0[i + 1]) / 2;
		}
	}
	void SetElectroPoten_remember()
	{
		for (int r = 1; r <= num_layer_y; ++r)
		{
			psi_0[r] = psi[r];
		}
		psi_0[0] = psi[0];
		psi_0[num_layer_y + 1] = psi[num_layer_y];
	}
	void SetTotal_q_Distrib()
	{
		for (int i = 1; i <= num_layer_y; ++i)
		{
			total_q[i] = alpha * phi[i] + phi_Na[i] - phi_Cl[i];
		}
	}
	void SetIon_Distrib()
	{
		for (int i = 0; i <= num_layer_y; ++i)
		{
			phi_Na[i] = phibulk_salt * exp(-psi[i]);
			phi_Cl[i] = phibulk_salt * exp(psi[i]);
		}
	}
	void SetSelf_Brownian()
	{
		SetIon_Distrib();
		SetTotal_q_Distrib();
		SetBoltzman_ElectroPoten();
		SetSolvent_Distrib();
		SetAverage_V();
		SetSelfCons_and_Mol_fields();
		SetMol_Strength();
		for (int r = 1; r <= num_layer_y; ++r)
		{
			phi_asterisk[r] = 0;
		}
	}
	void SetBrownian(int j, int i)
	{
		SetDistance_ij();
		SetFbond(); 
		SetAngleStrength();
		SetFsurface();
		SetMove_corpuscle(j, i);
	}
	void SetHybrid_method()
	{
		for (int i = 0; i < nstepSCF; ++i)
		{
			SetSelf_Brownian();
			for (int j = 0; j < nstepBD; ++j)
			{
				SetBrownian(j, i);
			}
			SetFinalDensity();
			if (i % print_to_pdb == 0) SetPrint_file(i);
			cout << i << endl;
		}
		output_data();
	}
	void SetPreparation()
	{
		SetPar_for_brown();
		SetMaindata();
		SetResize_vectors();
		SetPhi();
		SetPhi_asterisk_Psi();
	}
};

int main()
{
	setlocale(LC_ALL, "Ru");
	Brownian_Dynamics realization;
	realization.SetPreparation();
	realization.SetHybrid_method();
}
